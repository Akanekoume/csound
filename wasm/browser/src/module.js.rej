diff a/wasm/browser/src/module.js b/wasm/browser/src/module.js	(rejected hunks)
@@ -1,10 +1,13 @@
-import * as path from "path-browserify";
-import { WASI } from "@wasmer/wasi";
-import { WasmFs } from "@wasmer/wasmfs";
-import { inflate } from "pako";
-import { dlinit } from "@root/dlinit";
-import { csoundWasiJsMessageCallback, initFS } from "@root/filesystem/worker-fs";
-import { logWasmModule as log } from "@root/logger";
+// const path = goog.require("path-browserify");
+import path from "path-browserify";
+import { WASI } from "@wasmer/wasi/lib/index.esm.js";
+import { WasmFs } from "./filesystem/memfs/index";
+// import { inflate } from "pako/dist/pako.esm.mjs";
+import { dlinit } from "./dlinit";
+import { csoundWasiJsMessageCallback, initFS } from "./filesystem/worker-fs";
+import { logWasmModule as log } from "./logger";
+// const { Zlib } = require("zlibjs/bin/inflate.min.js");
+goog.require("Zlib.RawInflate");
 
 const PAGE_SIZE = 65536;
 
@@ -102,7 +105,7 @@ export default async function ({ wasmDataURI, withPlugins = [], messagePort }) {
   await wasmFs.volume.mkdirpSync("/sandbox");
 
   const wasmZlib = new Uint8Array(wasmDataURI);
-  const wasmBytes = inflate(wasmZlib);
+  const wasmBytes = Zlib.RawInflate(wasmZlib, {});
   const magicData = getBinaryHeaderData(wasmBytes);
   if (magicData === "static") {
     return [await loadStaticWasm({ messagePort, wasmBytes, wasmFs, wasi }), wasmFs];
